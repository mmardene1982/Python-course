1
00:00:00,730 --> 00:00:06,590
Here's this largest value one I've used
before and you know, away we go.

2
00:00:06,590 --> 00:00:09,510
We, you know, we have
largest_so_far, we check to see

3
00:00:09,510 --> 00:00:11,310
if the one we're looking at is better

4
00:00:11,310 --> 00:00:17,610
and if it is we keep it and then away we
go and we find that the largest is 17.

5
00:00:17,610 --> 00:00:18,730
What if...

6
00:00:19,840 --> 00:00:22,960
What would you have to change in this

7
00:00:22,960 --> 00:00:26,740
code to make this search for the
smallest of all the values?

8
00:00:29,210 --> 00:00:31,190
Like point, point where in the screen.

9
00:00:32,670 --> 00:00:35,870
Where, what would you have to change to

10
00:00:35,870 --> 00:00:38,440
make this look for the smallest
in the list of values?

11
00:00:40,210 --> 00:00:44,900
What is the nature of what's making this
about being largest?

12
00:00:44,900 --> 00:00:47,250
What would you change?
Okay.

13
00:00:49,260 --> 00:00:49,980
Pause if you like.

14
00:00:52,490 --> 00:00:57,140
So here is some things that you might do
to make it work about the smallest.

15
00:00:57,140 --> 00:00:58,670
So, hey, one thing we would do.

16
00:00:58,670 --> 00:01:02,688
Let's change the name of the variable.
We had a variable named largest_so_far.

17
00:01:02,688 --> 00:01:05,240
And now we'll change it to be called
smallest_so_far.

18
00:01:06,840 --> 00:01:09,498
Changing the variable name doesn't
change the program at all.

19
00:01:09,498 --> 00:01:11,480
But it makes the program easier to read.

20
00:01:11,480 --> 00:01:13,230
If the program works.

21
00:01:13,230 --> 00:01:14,940
So, it's like smallest so far.

22
00:01:14,940 --> 00:01:17,460
Okay, but that didn't make it
about being small.

23
00:01:17,460 --> 00:01:20,320
The thing that made it about being small

24
00:01:20,320 --> 00:01:23,030
is change this greater than to a less than.

25
00:01:24,250 --> 00:01:27,580
Because we're kind of thinking when
we're doing largest so far, if the

26
00:01:27,580 --> 00:01:32,020
number we're looking at is bigger than
the largest so far, we keep it.

27
00:01:32,020 --> 00:01:34,210
If the number we're looking at in
the smallest is

28
00:01:34,210 --> 00:01:36,440
smaller than the smallest so far,
then we want to keep it.

29
00:01:36,440 --> 00:01:37,080
So this is like,

30
00:01:39,310 --> 00:01:42,790
this line here is the keeping line
and this is the when line.

31
00:01:42,790 --> 00:01:46,749
When to keep.

32
00:01:46,749 --> 00:01:48,370
We'll keep it if it's smaller.

33
00:01:49,420 --> 00:01:50,720
Okay?

34
00:01:50,720 --> 00:01:53,900
So that's the key, and so yeah,
so I name it smallest_so_far,

35
00:01:53,900 --> 00:01:57,680
whoop de do. That's good.
But the real thing that

36
00:01:57,680 --> 00:02:00,930
had this being about largeness and
smallness was whether this, this less

37
00:02:00,930 --> 00:02:04,490
than and greater than and this was the
repeated code that got re-checked

38
00:02:04,490 --> 00:02:08,590
over and over again.
So, but this still has a bug in it.

39
00:02:09,750 --> 00:02:12,320
So let's run this visually.

40
00:02:14,590 --> 00:02:15,330
Okay.

41
00:02:15,330 --> 00:02:17,610
So now we've got a variable called
smallest so far.

42
00:02:18,898 --> 00:02:21,230
We are going to check to see if
a series of numbers that

43
00:02:21,230 --> 00:02:24,000
I'm about to show you are smaller
than the smallest so far.

44
00:02:26,130 --> 00:02:30,375
So the first number is 9.
Is that smaller than negative 1?

45
00:02:32,240 --> 00:02:34,760
No, it's not.
Negative 1 is smaller.

46
00:02:34,760 --> 00:02:39,096
The second number is 41.
Is that smaller than negative 1?

47
00:02:39,096 --> 00:02:40,688
No, it is not.

48
00:02:40,688 --> 00:02:43,409
The next number is 12.
Is that smaller than negative 1?

49
00:02:43,409 --> 00:02:44,310
No.

50
00:02:44,310 --> 00:02:47,180
Negative 1 is smaller than 12.

51
00:02:47,180 --> 00:02:50,294
3? No, not smaller.

52
00:02:50,294 --> 00:02:53,673
74? No, not smaller.

53
00:02:53,673 --> 00:02:56,160
15? Not smaller.

54
00:02:56,160 --> 00:02:58,890
So, we're all done.

55
00:02:58,890 --> 00:03:02,590
Yay, and the smallest number we saw
in the list is...

56
00:03:05,000 --> 00:03:08,700
Negative 1?
Negative 1 wasn't even in the list.

57
00:03:08,700 --> 00:03:11,190
So that's not a very good program.

58
00:03:14,740 --> 00:03:17,880
So let's take a look at what went wrong
with this program.

59
00:03:17,880 --> 00:03:19,990
So we fixed it, we fixed it as
best we could. Right?

60
00:03:21,050 --> 00:03:25,590
We made it, we changed the words
largest to smallest and yay, that'll fix.

61
00:03:25,590 --> 00:03:27,920
Just makes it more readable, doesn't
actually change the program.

62
00:03:27,920 --> 00:03:31,530
And we made this less than, so now what
happens is it comes in,

63
00:03:31,530 --> 00:03:36,250
if 3 is less than negative 1, smallest so
far of course is negative 1.

64
00:03:36,250 --> 00:03:38,510
It, this just never runs.

65
00:03:38,510 --> 00:03:40,014
This never runs. And so

66
00:03:40,014 --> 00:03:45,090
as we print, smallest_so_far stays
negative 1 and oops, that

67
00:03:45,090 --> 00:03:51,420
should be negative 1, right there.
[LAUGH] I'm sorry, I forgot to fix that.

68
00:03:51,420 --> 00:03:53,520
Here, let me magically fix that.

69
00:03:54,950 --> 00:03:56,520
Boom. [SNAP]

70
00:03:56,520 --> 00:04:00,340
So let's take a look at what
went wrong with this.

71
00:04:00,340 --> 00:04:02,935
So here we have the code.
smallest_so_far is negative 1.

72
00:04:02,935 --> 00:04:05,383
We have it fixed so we're checking,
looking for smaller

73
00:04:05,383 --> 00:04:09,060
numbers rather than larger numbers, by
turning this to less than.

74
00:04:09,060 --> 00:04:16,110
But the first time through,
smallest_so_far is negative 1 and the_num is 3.

75
00:04:16,110 --> 00:04:21,173
3 is not less than negative 1, so we skip
through and the printout of the

76
00:04:21,173 --> 00:04:23,299
first line is negative 1 3.

77
00:04:23,299 --> 00:04:27,320
And it doesn't take long to realize that
it's just going to keep doing this.

78
00:04:27,320 --> 00:04:30,380
smallest_so_far is going to stay
negative 1,

79
00:04:30,380 --> 00:04:32,620
no matter what we look at on this side.

80
00:04:32,620 --> 00:04:34,090
And then we're going to come out
at the end.

81
00:04:35,240 --> 00:04:40,225
And we end up with negative 1 as the
answer. Not very good.

82
00:04:40,225 --> 00:04:42,910
[SIGH].

83
00:04:42,910 --> 00:04:43,810
So the question is...

84
00:04:47,090 --> 00:04:51,220
What should we make this value be?
Negative 1?

85
00:04:51,220 --> 00:04:54,210
It barely worked in the largest because we
were working with positive

86
00:04:54,210 --> 00:04:57,320
numbers and so starting with negative 1
as the largest so far

87
00:04:57,320 --> 00:05:00,286
was a reasonable assumption as
long as the numbers were all positive.

88
00:05:00,286 --> 00:05:02,558
[SOUND].

89
00:05:02,558 --> 00:05:05,839
But what would be the number
to choose here?

90
00:05:05,839 --> 00:05:07,000
Think about that for a second.

91
00:05:07,000 --> 00:05:08,350
Pause if you have to.

92
00:05:08,350 --> 00:05:11,568
Let me clear it.
Let me make it real clear.

93
00:05:11,568 --> 00:05:14,695
[SOUND].
What's the right thing

94
00:05:14,695 --> 00:05:19,391
to put here? Okay.

95
00:05:19,391 --> 00:05:25,811
So, what? A million?

96
00:05:25,811 --> 00:05:31,524
That might work, a million might work.
But what if this number, you know,

97
00:05:31,524 --> 00:05:37,210
was, you know, what if, what if all
these numbers were larger

98
00:05:37,210 --> 00:05:40,020
than a million, okay?
Then, then that wouldn't work.

99
00:05:40,020 --> 00:05:45,200
So the problem is there's no real good
value, unless you could make this be

100
00:05:45,200 --> 00:05:50,100
somehow infinity, okay?
You could make this be infinity.

101
00:05:51,310 --> 00:05:57,010
But there is a way to do this in Python.
And it's a really kind of cool technique.

102
00:05:57,010 --> 00:05:59,730
It's sort of a way we signal ourselves,

103
00:05:59,730 --> 00:06:02,550
and that is we're going to use
a special value.

104
00:06:02,550 --> 00:06:03,318
Not negative 1.

105
00:06:03,318 --> 00:06:07,340
It's not a number. And the special value
we're going to use is None.

106
00:06:08,890 --> 00:06:14,160
It's a different type. It's not a number,
it's itself its own type.

107
00:06:14,160 --> 00:06:16,750
So what we're going to do is mark
smallest as "None".

108
00:06:16,750 --> 00:06:18,900
And, and, and sort of at a high level what

109
00:06:18,900 --> 00:06:22,990
we're really saying is we haven't seen
anything so far.

110
00:06:22,990 --> 00:06:25,940
The smallest we've seen so far is none.

111
00:06:25,940 --> 00:06:28,140
We've not seen anything so far.

112
00:06:28,140 --> 00:06:31,020
Now we have to change our loop,
our little if inside the loop.

113
00:06:31,020 --> 00:06:33,480
This is this intelligence in the middle.

114
00:06:33,480 --> 00:06:35,580
First we say if smallest is None.

115
00:06:35,580 --> 00:06:39,300
is is an operator, part of the
Python language.

116
00:06:39,300 --> 00:06:43,190
If smallest is None, exactly the
same as None,

117
00:06:43,190 --> 00:06:45,430
then the smallest we've seen so far
is the value.

118
00:06:45,430 --> 00:06:50,132
Now this is going to happen the first time
[SOUND].

119
00:06:50,132 --> 00:06:53,268
Because smallest starts out None and then
as soon as we set smallest

120
00:06:53,268 --> 00:06:56,808
to the value, it's going to be that first
number, so it's going to be 9.

121
00:06:56,808 --> 00:06:59,947
Okay? So the smallest is quickly
going to become 9.

122
00:06:59,947 --> 00:07:06,010
Then we print out the new, the smallest
is 9 after we've seen the 9.

123
00:07:06,010 --> 00:07:10,010
Then we go up to the top and we say, is
smallest None?

124
00:07:10,010 --> 00:07:14,219
And the answer is no it is not,
because smallest is now 9.

125
00:07:14,219 --> 00:07:19,080
Then this else-if is going to ask, is the
value we're looking at, which is 41,

126
00:07:19,080 --> 00:07:23,650
is the value less than smallest?
Well, no, it is not.

127
00:07:23,650 --> 00:07:25,360
9 is smaller than 41.

128
00:07:25,360 --> 00:07:29,090
And, so in a sense, after the
first time it's executed,

129
00:07:29,090 --> 00:07:31,050
after the first time the statement
is executed,

130
00:07:31,050 --> 00:07:32,800
this is going to always be false, right?

131
00:07:32,800 --> 00:07:35,200
Because smallest is no longer 1
and this is going to be

132
00:07:35,200 --> 00:07:37,850
the thing that really is operating.

133
00:07:37,850 --> 00:07:39,270
And then it's going to work.

134
00:07:39,270 --> 00:07:42,380
And when we, you know, smallest will
become 9.

135
00:07:42,380 --> 00:07:44,270
The smallest so far is 9, but then we see

136
00:07:44,270 --> 00:07:47,955
the 3 finally, and the value of
the 3 is less than 9.

137
00:07:47,955 --> 00:07:50,520
And so then we take 3 and we stick it into

138
00:07:50,520 --> 00:07:54,560
smallest and we end up with this,
and then the loop

139
00:07:54,560 --> 00:07:57,315
runs some more times, and when
we're all done we have 3.

140
00:07:58,510 --> 00:08:02,860
So the trick here is we put this
None in, and we have a

141
00:08:02,860 --> 00:08:06,510
little more if code to check to see
if we haven't seen anything so far.

142
00:08:06,510 --> 00:08:08,584
This is what, you can think of this

143
00:08:08,584 --> 00:08:14,205
as a way to trigger on the first,
first iteration.

144
00:08:14,205 --> 00:08:16,557
Special code that's really going to, it
could, it looks at it

145
00:08:16,557 --> 00:08:19,499
on each iteration, but it's never true
after the first iteration.

146
00:08:20,530 --> 00:08:22,410
Okay? So that's just a technique.

147
00:08:25,150 --> 00:08:27,840
So this is and the is not operator,
I think it's a real elegant thing.

148
00:08:27,840 --> 00:08:34,760
Don't start overusing it. It's,
at a low level

149
00:08:34,760 --> 00:08:38,780
its real meaning is exactly the
same as in type and value.

150
00:08:40,570 --> 00:08:44,040
There's an is and there's an
is not, but don't, like,

151
00:08:44,040 --> 00:08:48,530
say, like, if, don't do things like
saying if i equals.

152
00:08:48,530 --> 00:08:53,070
Oops.
I won't even let myself type the bad code.

153
00:08:53,070 --> 00:08:55,850
if i is 4.

154
00:08:55,850 --> 00:08:59,030
Don't say that, okay? Don't say that.

155
00:08:59,030 --> 00:09:00,680
Don't do if i is 4.

156
00:09:03,490 --> 00:09:07,078
It may work in certain situations.
It's really best used in very limited

157
00:09:07,078 --> 00:09:09,564
situations where you're checking
for some of these

158
00:09:09,564 --> 00:09:13,735
special values like None and False.

159
00:09:13,735 --> 00:09:14,570
Okay.

160
00:09:14,570 --> 00:09:18,810
The problem is if you use equality here,
it tries to kind of

161
00:09:18,810 --> 00:09:23,586
convert values and it may end up
giving you a false yes.

162
00:09:23,586 --> 00:09:27,450
And so is is a stronger equality than
simple equals.

163
00:09:29,190 --> 00:09:35,710
Equals is same value, same numeric value,
whereas is is exactly the same thing.

164
00:09:35,710 --> 00:09:38,978
But don't, don't overuse is. Use
double equals

165
00:09:38,978 --> 00:09:42,140
95% of the time and use is when you're

166
00:09:42,140 --> 00:09:45,530
checking if it's one of these special
constants like True or False.

167
00:09:46,890 --> 00:09:47,390
Okay?

168
00:09:49,020 --> 00:09:52,340
Okay.
So this is a iterations.

169
00:09:52,340 --> 00:09:54,190
I mean our loops are going to get more
sophisticated and

170
00:09:54,190 --> 00:09:56,570
we have more interesting things
to do, but we,

171
00:09:56,570 --> 00:09:57,940
you know, we talked about some

172
00:09:57,940 --> 00:10:01,370
indefinite loops, definite loops,
iteration variables.

173
00:10:01,370 --> 00:10:06,130
Some patterns like maximum, minimum,
summing, averaging, you know.

174
00:10:06,130 --> 00:10:10,490
We introduced the concept of None, you
know, and, and so this is.

175
00:10:10,490 --> 00:10:13,320
We're getting there, we've got a couple
more chapters before we really

176
00:10:13,320 --> 00:10:16,470
start hitting the data analysis, so see
you in the next lecture.

