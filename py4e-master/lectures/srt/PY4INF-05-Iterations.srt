00:00:00,120 --> 00:00:03,760
Hello and welcome to Chapter 5,
loops and iteration.

2
00:00:03,760 --> 00:00:08,240
As always, this lecture is copyright
Creative Commons Attribution, including

3
00:00:08,240 --> 00:00:12,680
the audio and video and, and the
slides, and the book even.

4
00:00:12,680 --> 00:00:18,800
So, now we're getting to our
fourth basic pattern.

5
00:00:18,800 --> 00:00:22,180
We've talked about sequential, where
steps happen one after another.

6
00:00:22,180 --> 00:00:25,270
We've talked about conditional, where
steps may or may not happen.

7
00:00:25,270 --> 00:00:27,580
In Chapter Four we talked about
the store and retrieve pattern.

8
00:00:27,580 --> 00:00:29,750
And now we're going to talk
about the looping pattern.

9
00:00:29,750 --> 00:00:33,820
And the looping pattern is the last
of our really foundational ones, and

10
00:00:33,820 --> 00:00:38,840
it potentially is the most important one,
because it's the thing that allows us

11
00:00:38,840 --> 00:00:41,540
to get computers to do lots of
things that, say,

12
00:00:41,540 --> 00:00:45,770
humans might get tired of,
but computers don't tire of.

13
00:00:45,770 --> 00:00:50,460
And so after this we'll start
sort of becoming a little more

14
00:00:50,460 --> 00:00:52,710
skilled in the basic language
capabilities.

15
00:00:52,710 --> 00:00:56,120
We'll talk about strings and, and
then start to talk about files.

16
00:00:56,120 --> 00:01:00,830
Add start doing some real work after we
get done with this, so bear with us.

17
00:01:00,830 --> 00:01:03,380
It's going to be a while,
but we'll get there.

18
00:01:03,380 --> 00:01:07,050
We'll get there.
So, welcome to repeated steps.

19
00:01:07,050 --> 00:01:12,760
This is the example that I had in the
first, first lecture, Chapter 1.

20
00:01:12,760 --> 00:01:15,310
And the basic idea, just to review,

21
00:01:15,310 --> 00:01:18,150
is that you have this while keyword.

22
00:01:18,150 --> 00:01:20,620
The while keyword sort of
functions like an if in that

23
00:01:20,620 --> 00:01:23,890
it implicitly has a decision that
it's going to make.

24
00:01:23,890 --> 00:01:26,890
And it's either going to do
the code in the

25
00:01:26,890 --> 00:01:29,860
indented block or not do it,
or skip it basically.

26
00:01:29,860 --> 00:01:33,020
Alright?
So you either do it or you skip it.

27
00:01:33,020 --> 00:01:36,280
The difference between the while
and the if is that it's going

28
00:01:36,280 --> 00:01:40,780
to do it many times, as long as this
question that we have remains true.

29
00:01:40,780 --> 00:01:42,500
Okay?

30
00:01:42,500 --> 00:01:48,100
And so, in this case, n is 5, while n
greater than 0 functions like an if.

31
00:01:48,100 --> 00:01:52,850
So yes, it's going to run it.
Prints out 5, subtracts 1, so it's 4.

32
00:01:52,850 --> 00:01:54,160
Goes back up.

33
00:01:54,160 --> 00:01:58,100
Goes back up and asks the question again,
is n still greater than 0?

34
00:01:58,100 --> 00:02:00,830
Well, since it's 4, yes,
we'll continue on.

35
00:02:00,830 --> 00:02:05,823
Out comes 4 then n gets subtracted.
3, 2, 3, 2, and then

36
00:02:05,823 --> 00:02:09,579
we come through, we print 1.
Print 1.

37
00:02:09,579 --> 00:02:13,230
We subtract n to 0. We go up,
we go back up.

38
00:02:13,230 --> 00:02:16,940
n is now not greater than 0, so we come

39
00:02:16,940 --> 00:02:20,730
up and we execute outside the loop,
we leave the loop.

40
00:02:20,730 --> 00:02:22,630
And that really means in the
Python code we

41
00:02:22,630 --> 00:02:26,360
skip to whatever is lined with
the while statement.

42
00:02:26,360 --> 00:02:29,290
The same indent level as
the while statement.

43
00:02:29,290 --> 00:02:31,262
And so that's how it works, and

44
00:02:31,262 --> 00:02:36,050
I just print n at the end here to remind
ourselves that n ended up at 0, not at 1,

45
00:02:36,050 --> 00:02:38,930
the last thing we printed out
in the loop. The last thing we

46
00:02:38,930 --> 00:02:42,800
printed out in the loop was the 1,
but n ended up at 0 because

47
00:02:42,800 --> 00:02:45,670
it was, this loop was going to run
as long as n was greater than 0,

48
00:02:45,670 --> 00:02:49,830
so n had to sort of be not greater
than 0 to get out of the loop.

49
00:02:49,830 --> 00:02:50,380
Okay?

50
00:02:50,380 --> 00:02:52,610
So that's basically a 
review of what we've done.

51
00:02:54,000 --> 00:02:56,170
Now, oh, wait, wait, wait, wait,

52
00:02:56,170 --> 00:02:59,460
wait, something else.
Iteration variables.

53
00:03:00,740 --> 00:03:04,440
Okay, so the key to this is 
these loops can't run forever.

54
00:03:04,440 --> 00:03:06,010
We don't want them to run forever.

55
00:03:06,010 --> 00:03:08,310
We want them to run until,
as long as we want them to run.

56
00:03:08,310 --> 00:03:11,570
They may run a very long time,
but not forever.

57
00:03:11,570 --> 00:03:13,300
There's got to be a way to get
out of them, otherwise we

58
00:03:13,300 --> 00:03:15,950
call them infinite loops, which
we'll talk about in the next slide.

59
00:03:15,950 --> 00:03:19,950
And so the iteration variable
is generally some variable

60
00:03:19,950 --> 00:03:21,299
that is changing each

61
00:03:21,299 --> 00:03:26,004
time through the loop, and we're changing
it by subtracting 1 to it, from it.

62
00:03:26,004 --> 00:03:28,227
And so this thing is going to keep
running, and we

63
00:03:28,227 --> 00:03:30,985
can pretty much see that Oh, this is
going to exit, right?

64
00:03:30,985 --> 00:03:34,774
Whatever n is, it could be a large number,
but eventually it's going to get to 0.

65
00:03:34,774 --> 00:03:35,292
Right?

66
00:03:35,292 --> 00:03:40,720
So the iteration variable controls how
many times the loop runs.

67
00:03:40,720 --> 00:03:43,540
And it also allows us to do something
different inside the loop.

68
00:03:43,540 --> 00:03:44,870
And, of course, this is like a trivial

69
00:03:44,870 --> 00:03:47,420
loop, where we're just printing the
iteration variable.

70
00:03:47,420 --> 00:03:50,100
But it just means that this
loop is going to run

71
00:03:50,100 --> 00:03:53,730
five times and it's going to do something
potentially different each time.

72
00:03:53,730 --> 00:03:55,690
If you just ran the loop that
did the same thing over

73
00:03:55,690 --> 00:03:58,400
and over and over again, with no data
changing, that's kind of dull and pointless.

74
00:03:58,400 --> 00:04:01,147
So just because you have an
iteration variable

75
00:04:01,147 --> 00:04:05,510
doesn't mean that you've properly
constructed your loop.

76
00:04:05,510 --> 00:04:09,250
It's a, it's a common problem or
something we want to avoid,

77
00:04:09,250 --> 00:04:13,010
is an infinite loop. And here is a, a
carefully constructed loop.

78
00:04:13,010 --> 00:04:15,540
We start n at 5 at the beginning.

79
00:04:15,540 --> 00:04:18,770
We have a good question at the end,
while n greater than 0.

80
00:04:18,770 --> 00:04:20,120
It's going to run this

81
00:04:20,120 --> 00:04:22,035
as long as n is greater than 0.

82
00:04:23,100 --> 00:04:25,740
But the problem is, is we don't
change in the little block.

83
00:04:25,740 --> 00:04:27,440
We don't change the n.

84
00:04:27,440 --> 00:04:29,810
Which means it's going to come back
and n is going to be 5.

85
00:04:29,810 --> 00:04:31,840
And it's going to run this and
n is going to be 5.

86
00:04:31,840 --> 00:04:34,100
And it's going to run this and
n is going to be 5.

87
00:04:34,100 --> 00:04:36,930
And so this is an infinite loop, which
means this loop will never exit.

88
00:04:36,930 --> 00:04:38,530
It will never get out,

89
00:04:39,602 --> 00:04:43,310
it's just going to run forever in here,
because n is not changing.

90
00:04:43,310 --> 00:04:45,250
Neither of these statements change n.

91
00:04:45,250 --> 00:04:49,580
So part of the iteration variable is there
needs to be something that changes

92
00:04:49,580 --> 00:04:51,870
so that the loop will ultimately
make progress to

93
00:04:51,870 --> 00:04:54,210
accomplish what it is and
know when to stop.

94
00:04:54,210 --> 00:04:56,500
So this is an infinite loop
and, of course,

95
00:04:56,500 --> 00:05:01,470
Lather, Rinse, Repeat is commonly put on
shampoo and conditioner.

96
00:05:01,470 --> 00:05:03,520
And so you know, you can,
next time you are

97
00:05:03,520 --> 00:05:04,755
in the shower, take a look at
your shampoo and

98
00:05:04,755 --> 00:05:07,905
conditioner and find the
infinite loop that's,

99
00:05:07,905 --> 00:05:12,120
that's on most bottles of
shampoo and conditioner.

100
00:05:14,350 --> 00:05:15,390
Now here is another loop,

101
00:05:17,970 --> 00:05:20,460
just to emphasize that it's
possible to structure

102
00:05:20,460 --> 00:05:22,810
these loops in a way that they never run.

103
00:05:22,810 --> 00:05:24,990
So this function is, is an if.

104
00:05:24,990 --> 00:05:27,510
The while functions as an if.

105
00:05:27,510 --> 00:05:31,720
And so when n is set to 0 and
we ask the question,

106
00:05:31,720 --> 00:05:34,590
it is literally going to make the
decision based on n greater than 0.

107
00:05:34,590 --> 00:05:38,780
Well it is not greater than 0, so it's
going to go right by it, over

108
00:05:38,780 --> 00:05:43,270
here it's going to come in here and go
right to there and never run these

109
00:05:43,270 --> 00:05:46,850
lines of code. And that's, we
call this a zero trip loop.

110
00:05:48,990 --> 00:05:51,850
And that's okay.
I mean, this is a silly one, of course.

111
00:05:53,570 --> 00:05:57,500
It just shows that the test, the
question that's being asked is

112
00:05:57,500 --> 00:06:00,660
above the lines that make up
the body of the loop.

113
00:06:00,660 --> 00:06:03,270
And if it's false, the loop never runs.

114
00:06:03,270 --> 00:06:06,650
So it's possible that these loops
have zero trips.

115
00:06:06,650 --> 00:06:07,690
Okay?

116
00:06:07,690 --> 00:06:09,100
So, that's a loop.

117
00:06:09,100 --> 00:06:14,310
Now, there are more than one way
to sort of control the flow

118
00:06:14,310 --> 00:06:15,680
of a loop.

119
00:06:15,680 --> 00:06:17,540
The basic flow of the loop is
when it gets to the

120
00:06:17,540 --> 00:06:20,572
bottom, it goes back up to the while,
and does the check.

121
00:06:20,572 --> 00:06:22,240
This is a different way of getting out of

122
00:06:22,240 --> 00:06:24,690
a loop or controlling the execution
of a loop.

123
00:06:24,690 --> 00:06:28,060
There is a keyword or a part of
the Python language called...

124
00:06:29,630 --> 00:06:31,250
What color do I got?

125
00:06:31,250 --> 00:06:34,460
No, green's over here.
Called break.

126
00:06:34,460 --> 00:06:38,510
If you look back at the reserved words,
break was one of the reserved words.

127
00:06:38,510 --> 00:06:39,450
Break says,

128
00:06:39,450 --> 00:06:42,920
hey, if I'm in a loop, stop the loop.
All right?

129
00:06:42,920 --> 00:06:43,740
Get out of this loop.

130
00:06:43,740 --> 00:06:45,550
I'm done with this loop.

131
00:06:45,550 --> 00:06:47,560
And so here's this loop.

132
00:06:47,560 --> 00:06:49,420
Now the interesting thing we've
done is I've

133
00:06:49,420 --> 00:06:51,110
just got done talking to you about
infinite loops.

134
00:06:51,110 --> 00:06:54,760
We have just constructed an
"infinite loop", because the

135
00:06:54,760 --> 00:06:58,180
question is right there, and
the answer is yes.

136
00:06:58,180 --> 00:06:58,930
True.

137
00:06:58,930 --> 00:06:59,280
True.

138
00:06:59,280 --> 00:07:01,500
And that's a way to construct
an infinite loop.

139
00:07:01,500 --> 00:07:03,140
We've done this because we have a
different

140
00:07:03,140 --> 00:07:04,490
way of getting out of the loop, so we've

141
00:07:04,490 --> 00:07:07,060
constructed a loop that,
just on the face of it,

142
00:07:07,060 --> 00:07:10,050
just looking at that line, looks
like an infinite loop.

143
00:07:10,050 --> 00:07:13,350
So what this loop does is it
reads a line of input,

144
00:07:13,350 --> 00:07:17,320
checks to see if the string that
we've entered is done.

145
00:07:17,320 --> 00:07:20,740
And if it is, we're going to
skip out with this break

146
00:07:20,740 --> 00:07:23,170
and get out of the loop, otherwise
we're going to print it.

147
00:07:23,170 --> 00:07:24,950
So at a high level, what this loop is

148
00:07:24,950 --> 00:07:28,510
going to do is prompt for
strings of characters

149
00:07:28,510 --> 00:07:30,000
until we enter done.

150
00:07:30,000 --> 00:07:31,140
And that's exactly what it does.

151
00:07:31,140 --> 00:07:33,100
It prompts, we say hello there,
it prints that out.

152
00:07:33,100 --> 00:07:35,290
We say, we say finished, it
prints that out.

153
00:07:35,290 --> 00:07:37,030
We say done, and it's done.

154
00:07:37,030 --> 00:07:39,700
So it, when we say done, it comes out and

155
00:07:39,700 --> 00:07:42,760
finishes the loop, and, and that's
the end of the program.

156
00:07:42,760 --> 00:07:43,540
Okay?

157
00:07:43,540 --> 00:07:46,150
So, to look at this in some more detail.

158
00:07:48,200 --> 00:07:51,780
The first time, it comes in,
does the raw input.

159
00:07:51,780 --> 00:07:54,040
Because True is true, so it's
going to run it.

160
00:07:54,040 --> 00:07:57,600
And then we enter hello there.

161
00:07:57,600 --> 00:07:59,950
It checks to see if what we entered is
equal to the string done.

162
00:07:59,950 --> 00:08:02,480
It is not, so it skips and it
does the print.

163
00:08:03,600 --> 00:08:06,590
And we do this one more time,
we type finished.

164
00:08:06,590 --> 00:08:10,020
And then the line is not done,
that variable

165
00:08:10,020 --> 00:08:11,860
line does not have the value done in it.

166
00:08:11,860 --> 00:08:13,300
So we print that. We come in

167
00:08:13,300 --> 00:08:16,700
one more time, but this time
this is true, so it

168
00:08:16,700 --> 00:08:21,180
goes in and executes the break
and then it escapes the loop.

169
00:08:21,180 --> 00:08:22,290
And so you can think of...

170
00:08:23,870 --> 00:08:24,240
Right?

171
00:08:24,240 --> 00:08:26,300
Here is the body of this loop,

172
00:08:26,300 --> 00:08:29,700
because that's where the indentation
starts and ends.

173
00:08:29,700 --> 00:08:34,730
The break says, break me out of the
current loop that I am in

174
00:08:34,730 --> 00:08:38,210
and get to that next line that has the
same indent as the while.

175
00:08:38,210 --> 00:08:42,050
So, whatever it is, break says, we are
done with this loop.

176
00:08:42,050 --> 00:08:45,310
When that statement executes, we are
done with the loop.

177
00:08:45,310 --> 00:08:46,720
We're finished with the loop.

178
00:08:46,720 --> 00:08:50,970
It'll run until that executes
because we got this set to be while True.

179
00:08:53,180 --> 00:08:57,160
Okay, so there's a simpler, I mean this is
sort of a simple way to draw this.

180
00:08:57,160 --> 00:09:01,100
Break is sort of a jump to the statement
immediately following the loop.

181
00:09:02,530 --> 00:09:04,418
If you really want to picture this, I think

182
00:09:04,418 --> 00:09:06,830
of this as a kind of like a Star Trek
transporter.

183
00:09:06,830 --> 00:09:11,590
Where you kind of come into break and
then [SOUND] your molecules are sent

184
00:09:11,590 --> 00:09:15,515
to the four corners of the universe, and
you reassemble outside of the loop.

185
00:09:15,515 --> 00:09:18,590
And so if we look at this in sort of
my little road map

186
00:09:18,590 --> 00:09:20,536
version of these things, right?

187
00:09:20,536 --> 00:09:23,640
The while loop is going to run for 
a while, yada, yada.

188
00:09:23,640 --> 00:09:25,830
There can actually be more
than one break

189
00:09:25,830 --> 00:09:29,880
as long as they only get this. But the
moment that somehow, some if or

190
00:09:29,880 --> 00:09:36,110
whatever hits the break, then it gets out
completely and so it escapes the loop.

191
00:09:36,110 --> 00:09:40,740
And so it sort of like you, you,
you're zoom, zoom,

192
00:09:40,740 --> 00:09:43,520
zoom, zoom, zoom, zoom, you
come in here and then you are,

193
00:09:43,520 --> 00:09:48,420
you are re-materialized outside the loop.
That's what the break does, okay?

194
00:09:48,420 --> 00:09:52,570
So, break is one way to control the
execution of loops.

195
00:09:54,530 --> 00:09:57,090
Now, another way to control
the execution of

196
00:09:57,090 --> 00:10:00,000
loops, that doesn't actually exit the
loop, is called continue.

197
00:10:01,000 --> 00:10:06,630
Continue basically says, hey, I'm done
with this iteration of the loop.

198
00:10:06,630 --> 00:10:09,620
Now each time through the loop, we
call that an iteration.

199
00:10:09,620 --> 00:10:13,300
Continue says, I don't want to
stop the loop, but I

200
00:10:13,300 --> 00:10:17,590
want to stop this iteration and
advance to the next iteration.

201
00:10:17,590 --> 00:10:20,100
And so what we have here is
we have the same basic loop,

202
00:10:20,100 --> 00:10:23,040
a while True which kind of
makes us an infinite loop.

203
00:10:24,570 --> 00:10:27,420
We're going to read a line prompting
with a less than sign.

204
00:10:28,800 --> 00:10:30,690
And if it's done, we are going to
break, that code is

205
00:10:30,690 --> 00:10:32,990
down here, and we are going to
print it if we fall through.

206
00:10:32,990 --> 00:10:34,920
So normally we'll be reading and

207
00:10:34,920 --> 00:10:38,300
printing, and if the line is done,
we are going to break out.

208
00:10:38,300 --> 00:10:40,700
That's we just got done doing.
But the new part is right here.

209
00:10:41,960 --> 00:10:44,120
And this is, we'll learn this
in the next chapter.

210
00:10:44,120 --> 00:10:46,636
If line sub 0, if the first character of

211
00:10:46,636 --> 00:10:50,650
the line, is a pound sign, we're
going to continue.

212
00:10:50,650 --> 00:10:54,300
And what continue says is it doesn't
actually get us out of the loop.

213
00:10:54,300 --> 00:10:56,230
It jumps back up to the top of the loop.

214
00:10:56,230 --> 00:11:00,060
Which means that it ignores,
for that iteration,

215
00:11:00,060 --> 00:11:01,860
the rest of the loop. Right?

216
00:11:01,860 --> 00:11:04,230
So if execution comes in here.

217
00:11:04,230 --> 00:11:05,740
I'm going to clear that.

218
00:11:06,880 --> 00:11:12,810
If execution comes in here and hits this
line, it goes back up to the while.

219
00:11:12,810 --> 00:11:13,700
Okay?

220
00:11:13,700 --> 00:11:17,190
Which means it, whatever this is, it's not
coming out of this if.

221
00:11:17,190 --> 00:11:19,100
It's going back up to the while.

222
00:11:19,100 --> 00:11:19,710
Okay?

223
00:11:19,710 --> 00:11:22,520
So continue ends the current
iteration and jumps to

224
00:11:22,520 --> 00:11:24,970
the top of the loop, and starts
the next iteration.

225
00:11:26,300 --> 00:11:28,380
And so if we look at how the code runs,

226
00:11:28,380 --> 00:11:32,300
hello there prints, pound sign with the
first character

227
00:11:32,300 --> 00:11:35,200
doesn't print, so there is
no printout right here.

228
00:11:35,200 --> 00:11:39,340
Print this is not done. And we enter done,
and then the loop ends.

229
00:11:39,340 --> 00:11:41,460
Now another way to sort of draw this is

230
00:11:41,460 --> 00:11:44,440
the continued jumps to the top
of the loop.

231
00:11:44,440 --> 00:11:49,600
It, it does run the question, right?
It does check the question.

232
00:11:49,600 --> 00:11:51,480
So here is another way to, to draw

233
00:11:51,480 --> 00:11:55,830
that picture. And so here again we have a
loop and it's happily running.

234
00:11:55,830 --> 00:11:57,503
And there can be breaks in there
and there could

235
00:11:57,503 --> 00:12:00,110
be continues in there, and as
long as we don't

236
00:12:00,110 --> 00:12:01,760
hit a break or continue, the
loop just sort of

237
00:12:01,760 --> 00:12:04,962
runs and goes up to the top.
And at some point, some if,

238
00:12:04,962 --> 00:12:09,020
we hit the continue. And
like a transporter, instead of

239
00:12:09,020 --> 00:12:11,320
going out of the loop, we go to
the top of the loop.

240
00:12:11,320 --> 00:12:15,600
But it's important that we go and
we check the question, right?

241
00:12:15,600 --> 00:12:16,505
So the continue is

242
00:12:16,505 --> 00:12:20,020
not likely to exit the loop
unless the question has become false.

243
00:12:20,020 --> 00:12:22,670
So the continue is likely to
come up here,

244
00:12:22,670 --> 00:12:25,540
run some more, then hit the continue.
It comes up here.

245
00:12:25,540 --> 00:12:26,640
Oops!
Oops, it did that backwards.

246
00:12:26,640 --> 00:12:27,830
Run some more.

247
00:12:27,830 --> 00:12:29,470
Clear this out.

248
00:12:29,470 --> 00:12:32,100
So, the continue could run
many times, right?

249
00:12:32,100 --> 00:12:33,110
So we have the loop.

250
00:12:33,110 --> 00:12:36,618
Loop runs a bunch of times, then
finally we hit the continue.

251
00:12:36,618 --> 00:12:37,900
Continue goes up to the top.

252
00:12:37,900 --> 00:12:40,690
If it's still true, we'll run the 
loop some more.

253
00:12:40,690 --> 00:12:42,136
Then you might hit the continue.

254
00:12:42,136 --> 00:12:43,606
Then you might go up to the top, come

255
00:12:43,606 --> 00:12:46,930
down, round and round and round and round,
hit the continue again.

256
00:12:46,930 --> 00:12:49,240
Go up to the top, yada, yada.

257
00:12:49,240 --> 00:12:52,610
Now in this, in this particular loop,
this break eventually

258
00:12:52,610 --> 00:12:55,240
is down here and that's how we 
get out, okay?

259
00:12:55,240 --> 00:12:58,040
So the continue goes back up
to the top of the loop.

260
00:13:00,020 --> 00:13:01,935
So these loops that we construct with the

261
00:13:01,935 --> 00:13:05,340
while keyword are what we call
indefinite loops.

262
00:13:05,340 --> 00:13:07,419
I mean, looking at the ones that we've

263
00:13:07,419 --> 00:13:09,630
written, which are two lines or six lines,

264
00:13:09,630 --> 00:13:12,800
we can kind of inspect them and
understand when they are going

265
00:13:12,800 --> 00:13:16,780
to stop, and we are going to know that
they're possible to stop them.

266
00:13:16,780 --> 00:13:20,130
A loop that won't stop is an infinite loop.

267
00:13:21,500 --> 00:13:24,864
Sometimes these loops can be rather [COUGH]
complex and you may not actually be able to

268
00:13:24,864 --> 00:13:29,910
look at them, because there are many lines
and, and so we don't know.

269
00:13:29,910 --> 00:13:32,460
And so, so if you, you have to be
real careful when you

270
00:13:32,460 --> 00:13:37,200
construct these to make sure that they
stop as, as things get more complicated.

271
00:13:37,200 --> 00:13:42,380
Now the cousin to indefinite loops are
definite loops.

272
00:13:42,380 --> 00:13:46,710
And definite loops is something where we
have a list of things or a set

273
00:13:46,710 --> 00:13:49,900
of things that are kind of a known set of
things, a finite set of things.

274
00:13:51,050 --> 00:13:53,270
And we are going to write a loop that's
going to go through that set of things 

275
00:13:53,270 --> 00:13:57,460
and do something to each thing
in that set of things.

276
00:13:57,460 --> 00:13:59,630
And the keyword that we use
for this is the for.

277
00:13:59,630 --> 00:14:05,130
So we use the Python for keyword that
says we are going to write a loop, but

278
00:14:05,130 --> 00:14:07,640
instead of it just running until some
condition

279
00:14:07,640 --> 00:14:09,320
becomes true or false or we hit a break,

280
00:14:10,320 --> 00:14:13,720
we're actually going to know how many
times this is going to run.

281
00:14:13,720 --> 00:14:16,640
Now you can actually use break and
continue in for loops.

282
00:14:16,640 --> 00:14:19,820
We call these definite loops because
the, how long

283
00:14:19,820 --> 00:14:23,120
they're going to run is kind of
well known, basically.

284
00:14:23,120 --> 00:14:26,630
So here's a simple definite loop, and it's
kind of like that while loop

285
00:14:26,630 --> 00:14:28,340
that we just got done looking at

286
00:14:28,340 --> 00:14:31,400
where it's counting down and then
saying blastoff.

287
00:14:31,400 --> 00:14:35,290
And so the way we construct this loop is
we have the for keyword,

288
00:14:35,290 --> 00:14:37,580
it's part of Python language,

289
00:14:37,580 --> 00:14:40,950
the in keyword, and then we 
have an iteration variable.

290
00:14:40,950 --> 00:14:43,700
I've chosen i as my iteration variable.

291
00:14:43,700 --> 00:14:46,590
And basically what we're saying is,
dear Python,

292
00:14:48,560 --> 00:14:52,970
run this indented block, and there's only
one line in the indented block.

293
00:14:52,970 --> 00:14:56,920
Run it once for each of the values
in this little list.

294
00:14:56,920 --> 00:15:00,590
This is a Python list, square brackets
make Python lists.

295
00:15:00,590 --> 00:15:02,250
Comma-separated values.

296
00:15:02,250 --> 00:15:05,210
So it says, I would like i to be 5,
then run this code.

297
00:15:05,210 --> 00:15:07,230
Then I would like i to be 4,
then run this code.

298
00:15:07,230 --> 00:15:09,430
Then I would like i to be 3,
then run this code.

299
00:15:09,430 --> 00:15:13,540
i should be 2, then run this code.
And i should be 1, then run this code.

300
00:15:13,540 --> 00:15:16,450
And so this is pretty clear,
and I like this word in.

301
00:15:17,810 --> 00:15:22,570
It says you know, doop, doop, doop, 
doop, doop, and then run this each time.

302
00:15:22,570 --> 00:15:27,810
And so out of that comes 5, 4, 3, 2, 1,
and then the loop is done.

303
00:15:27,810 --> 00:15:29,920
Python is doing all the tricky bits

304
00:15:29,920 --> 00:15:32,640
here, Python's figuring all these
things out for us

305
00:15:34,880 --> 00:15:38,570
and handling all this, and then we're done.
And so it's, it's, if you look at it,

306
00:15:38,570 --> 00:15:41,320
we have an iteration variable, but we
didn't have to increment it,

307
00:15:41,320 --> 00:15:44,920
we didn't have to do anything. Python took
care of a lot of things for us.

308
00:15:44,920 --> 00:15:47,850
And so when we're looping through
a known list of things,

309
00:15:47,850 --> 00:15:49,712
or later when we read a file,

310
00:15:49,712 --> 00:15:51,480
we're going to loop through
the lines in the file.

311
00:15:51,480 --> 00:15:54,460
And so the for loop is a really nice
powerful.

312
00:15:54,460 --> 00:15:58,100
And it's syntactically cleaner, it's
really quite nice.

313
00:15:58,100 --> 00:15:59,920
Now it's important to realize that you

314
00:15:59,920 --> 00:16:03,740
don't have to just loop through numbers.
I did that one with the set of

315
00:16:03,740 --> 00:16:05,330
descending numbers, so that
it was equivalent to the

316
00:16:05,330 --> 00:16:07,680
while loop that I started at the
beginning.

317
00:16:07,680 --> 00:16:11,510
But this is a loop where what it's
going to loop through is a list.

318
00:16:11,510 --> 00:16:14,970
Closed square brackets are a list in Python.

319
00:16:14,970 --> 00:16:18,990
This is a list of three strings, Joseph,
Glenn, and Sally.

320
00:16:18,990 --> 00:16:23,110
They're string constants, and then commas
are how we make lists.

321
00:16:24,370 --> 00:16:25,820
And so friends

322
00:16:25,820 --> 00:16:27,300
is a mnemonic variable.

323
00:16:27,300 --> 00:16:29,550
Python doesn't know anything about friends
in particular,

324
00:16:29,550 --> 00:16:31,960
but I've chosen this variable name
to be friends.

325
00:16:31,960 --> 00:16:35,110
And it's a list of three people, Joseph,
Glenn, and Sally.

326
00:16:35,110 --> 00:16:37,900
And so I have an iteration variable
called friend.

327
00:16:37,900 --> 00:16:40,150
And I'm going to loop through the
set of friends.

328
00:16:40,150 --> 00:16:42,410
Now Python doesn't know anything about
singular.

329
00:16:42,410 --> 00:16:44,260
Python doesn't know anything about plural.

330
00:16:44,260 --> 00:16:47,320
I'm just choosing these variable names
because it makes a lot of sense.

331
00:16:48,350 --> 00:16:50,894
This is a set of friends.
Because it has three of them in it.

332
00:16:50,894 --> 00:16:54,030
And this is a single friend.

333
00:16:54,030 --> 00:16:57,620
What it's really going to do is friend is
going to take on the successive

334
00:16:57,620 --> 00:17:00,600
of values Joseph, Glenn, and Sally,
and this little block of code

335
00:17:00,600 --> 00:17:05,160
is going to once for each of
those three items in the set, and

336
00:17:05,160 --> 00:17:10,200
the variable friend is going to take on
the successive values of that set.

337
00:17:10,200 --> 00:17:13,360
So out of this comes
three lines of printout.

338
00:17:13,360 --> 00:17:15,980
Happy New Year Joseph, Happy New Year
Glenn, Happy New Year Sally.

339
00:17:15,980 --> 00:17:19,940
Of course this is the i bit
right down here, but we just

340
00:17:19,940 --> 00:17:23,330
made it so, hey Python, look, how ever
many friends they are, run this

341
00:17:23,330 --> 00:17:26,820
code one time for each one, change this
variable friend to be each

342
00:17:26,820 --> 00:17:30,400
of the successive ones in order,
and then we print that we're done.

343
00:17:30,400 --> 00:17:30,888
Okay?

344
00:17:30,888 --> 00:17:32,860
So the for loop.

345
00:17:32,860 --> 00:17:34,860
Sort of if we go and try to make a
picture of the for loop.

346
00:17:34,860 --> 00:17:39,420
The for loop is kind of a powerful thing.
It's does, it does two things.

347
00:17:39,420 --> 00:17:41,080
It decides if we're done or not.

348
00:17:42,470 --> 00:17:44,060
Do we keep going in the loop?

349
00:17:44,060 --> 00:17:46,210
Or, well I mean as long as we keep

350
00:17:46,210 --> 00:17:49,280
going, we're going to advance
the i value, the iteration variable.

351
00:17:49,280 --> 00:17:52,660
It takes care of the responsibility of
changing the iteration variable.

352
00:17:52,660 --> 00:17:57,050
We do not have to add lines of code in
that change the iteration variable, okay?

353
00:17:57,050 --> 00:18:00,910
And so if we take a look, you know,
we come in.

354
00:18:00,910 --> 00:18:02,280
Are we done? We're not done.

355
00:18:02,280 --> 00:18:04,310
Set i to the right thing, then print it.

356
00:18:04,310 --> 00:18:07,190
Out comes 5. Advance i,

357
00:18:07,190 --> 00:18:09,370
advance i, print it. Advance it.

358
00:18:09,370 --> 00:18:10,170
Print it. Advance it. Print it. 

359
00:18:10,170 --> 00:18:12,500
Oh, now we're done.

360
00:18:12,500 --> 00:18:13,350
Right?

361
00:18:13,350 --> 00:18:16,510
i was not the thing that decided
when we were done.

362
00:18:16,510 --> 00:18:19,660
The for loop just keeps track
internally as i moves

363
00:18:19,660 --> 00:18:22,790
through these things and it
goes like oh, I'm all done.

364
00:18:22,790 --> 00:18:25,260
I'll take care of that, you finished.

365
00:18:25,260 --> 00:18:29,150
So it doesn't, there's no if in here,
so it's not like like if i equals 1, stop.

366
00:18:29,150 --> 00:18:31,780
No, no, no, it just says you told me
to do five things.

367
00:18:31,780 --> 00:18:32,360
I'm going to do five things

368
00:18:32,360 --> 00:18:33,710
and then we're going to stop.

369
00:18:33,710 --> 00:18:40,220
And so again the for loop, the for loop
here has got sort of two functions.

370
00:18:40,220 --> 00:18:43,910
It decides how long the loop is going to
run, and changes the

371
00:18:43,910 --> 00:18:47,570
iteration variable based on what you've
told it to, in this in clause.

372
00:18:48,690 --> 00:18:49,190
Okay?

373
00:18:50,310 --> 00:18:53,580
So I think in is a real elegant
construct.

374
00:18:53,580 --> 00:18:58,290
It's just a keyword, but it's 
sort of, if you think about math,

375
00:18:58,290 --> 00:18:59,680
if you're familiar with sets,

376
00:18:59,680 --> 00:19:02,120
it's like something inside of 
a set of something.

377
00:19:02,120 --> 00:19:03,980
I think it's a real pretty way
to think about it.

378
00:19:05,080 --> 00:19:07,350
And you can kind of think of it
a little more abstractly.

379
00:19:07,350 --> 00:19:10,640
That you say, well here's a little
indented block of code.

380
00:19:10,640 --> 00:19:11,080
Right?

381
00:19:11,080 --> 00:19:14,990
And I want it to run some number
of times for each

382
00:19:14,990 --> 00:19:18,660
of the i values in the set 5, 4, 3, 2, 1.

383
00:19:18,660 --> 00:19:19,950
That's how I kind of think of it.

384
00:19:19,950 --> 00:19:23,170
So I think that this is a 
real pretty syntax.

385
00:19:23,170 --> 00:19:25,490
Different languages have different
looping syntax.

386
00:19:25,490 --> 00:19:28,930
I think this is really a very
expressive, very pretty one.

387
00:19:32,720 --> 00:19:33,920
Yeah.

388
00:19:33,920 --> 00:19:36,870
So another way to, so, so, so one way to

389
00:19:36,870 --> 00:19:40,440
think about this picture is that, you
know, the for loop

390
00:19:40,440 --> 00:19:42,760
causes sort of repeated execution
in that we're

391
00:19:42,760 --> 00:19:45,410
driving in the circle and then we
stop, right?

392
00:19:45,410 --> 00:19:47,890
The other way to think about is to, to

393
00:19:47,890 --> 00:19:50,588
not, to think about a little more
abstractly, right?

394
00:19:50,588 --> 00:19:53,440
To say, hmm, you know, at the
end of the day, all I'm

395
00:19:53,440 --> 00:19:58,130
really telling Python is, I want to
execute this block of code five times,

396
00:19:58,130 --> 00:20:02,190
then I want the variable i to
change from, to these three values.

397
00:20:02,190 --> 00:20:04,030
So in a way, you could think of 
this as expanded

398
00:20:04,030 --> 00:20:06,960
is the for loop sets it to 5,
then runs your code.

399
00:20:06,960 --> 00:20:09,290
The for loop then sets it to 4,
runs your code.

400
00:20:09,290 --> 00:20:11,525
The for loop sets it to 3, runs your code.

401
00:20:11,525 --> 00:20:15,830
For loop sets it to 2, runs your code.
Sets it to 1, runs your code.

402
00:20:15,830 --> 00:20:18,740
These two ways of looking at it
are the same

403
00:20:19,910 --> 00:20:23,390
from your perspective, because
you're just asking Python

404
00:20:23,390 --> 00:20:24,590
to do something.

405
00:20:24,590 --> 00:20:28,030
Whether it does it this way, or
whether it does it this way,

406
00:20:28,030 --> 00:20:32,290
you hardly can tell the difference.
It's probably going to do it this way.

407
00:20:32,290 --> 00:20:37,150
But logically it's not that different.
It's not different from doing it this way.

408
00:20:37,150 --> 00:20:41,440
You're saying, run this block of code,
change i in the following way.

409
00:20:44,860 --> 00:20:48,600
Cool.
It's like, we don't have to worry.

410
00:20:48,600 --> 00:20:51,640
I mean, we can use, mentally,
either model of what's

411
00:20:51,640 --> 00:20:54,520
going on inside, because it doesn't
matter, because they're the same.

412
00:20:57,375 --> 00:21:00,330
Okay, so these definite loops
are really cool.

413
00:21:00,330 --> 00:21:02,960
Starting in a couple of chapters we'll
mostly use definite

414
00:21:02,960 --> 00:21:07,200
loops to go through lists or
dictionaries or tuples or files.

415
00:21:08,290 --> 00:21:09,970
And so that's a finite set of things.

416
00:21:09,970 --> 00:21:12,100
It can be a large set of things, but
it's a finite set of things.

417
00:21:13,680 --> 00:21:17,040
Okay. So now I want to talk about
loop idioms.

418
00:21:19,020 --> 00:21:24,200
Loop idioms are how we construct loops.

419
00:21:24,200 --> 00:21:28,080
And we're going to, the loops kind of
have some kind of a goal in mind.

420
00:21:28,080 --> 00:21:29,970
Finding the largest, we played with that.

421
00:21:29,970 --> 00:21:33,360
Finding the smallest, counting the 
number of things,

422
00:21:33,360 --> 00:21:36,230
looking for lines that start with pound
signs, something like that.

423
00:21:36,230 --> 00:21:39,630
They, they have a kind of a high-level
view of what they're supposed to do,

424
00:21:39,630 --> 00:21:43,830
and then we have to kind of build a
loop to accomplish that.

425
00:21:43,830 --> 00:21:47,600
And and this goes back to how we have to
think like a computer, right?

426
00:21:47,600 --> 00:21:50,000
We have to say, hey computer,

427
00:21:50,000 --> 00:21:52,080
do this over and over and over again,
and then I'll

428
00:21:52,080 --> 00:21:54,300
get what I want once you've done that
over and over again.

429
00:21:54,300 --> 00:21:55,760
You have to do something a million times.

430
00:21:55,760 --> 00:21:57,100
I'm not going to sit here and wait.

431
00:21:57,100 --> 00:21:59,030
At the end, I'll get what I want.

432
00:21:59,030 --> 00:22:00,770
So I call these kind of "smart loops",

433
00:22:00,770 --> 00:22:03,460
or how to kind of build
intelligence into loops.

434
00:22:06,170 --> 00:22:08,640
So, for example, we want the largest
number.

435
00:22:08,640 --> 00:22:09,400
Right?

436
00:22:09,400 --> 00:22:11,860
But we have to construct a loop that will

437
00:22:11,860 --> 00:22:15,020
get us the largest number thinking
like a computer.

438
00:22:15,020 --> 00:22:17,200
Okay? Thinking computationally.

439
00:22:17,200 --> 00:22:18,920
Thinking like a computer.

440
00:22:18,920 --> 00:22:21,550
So the idea is that we have some kind

441
00:22:21,550 --> 00:22:24,320
of a loop and we're going to
go through this list,

442
00:22:24,320 --> 00:22:28,170
some list of things, and this is
going to run a bunch of times.

443
00:22:28,170 --> 00:22:29,510
And, but the way we're going to do it is

444
00:22:29,510 --> 00:22:32,130
we're going to set something up
before the loop starts.

445
00:22:32,130 --> 00:22:35,720
We're going to do something to each of the
things that's being looked at,

446
00:22:35,720 --> 00:22:39,800
and at the end, we're going to get the
result we're looking for.

447
00:22:39,800 --> 00:22:40,560
Okay?

448
00:22:40,560 --> 00:22:43,310
And so in the middle it's kind of like
working.

449
00:22:43,310 --> 00:22:45,580
It's in the middle working,
da, da, da, da, da.

450
00:22:45,580 --> 00:22:47,270
And then here is the payoff.

451
00:22:47,270 --> 00:22:52,290
The payoff is at the end when we get the
information that we're interested in.

452
00:22:52,290 --> 00:22:55,880
So I will sort of use in the
next few examples

453
00:22:55,880 --> 00:22:57,880
this simple loop,

454
00:22:57,880 --> 00:22:59,870
and right now it doesn't do much.

455
00:22:59,870 --> 00:23:02,140
It does a print Before and it
has this variable

456
00:23:02,140 --> 00:23:06,180
thing that goes through the successive
values of these numbers.

457
00:23:06,180 --> 00:23:08,950
And it prints it out, right?
So that middle part says

458
00:23:08,950 --> 00:23:12,500
run this six times, once for
each of those values.

459
00:23:12,500 --> 00:23:13,330
And then After. Okay?

460
00:23:13,330 --> 00:23:16,710
And so we will add some intelligence
at the beginning, we'll add

461
00:23:16,710 --> 00:23:19,910
some intelligence in the middle, and we'll
add some intelligence at the end.

462
00:23:19,910 --> 00:23:22,790
And then the whole thing will
accomplish what we want.

463
00:23:22,790 --> 00:23:26,170
Right now this is kind of not that
intelligent.

464
00:23:26,170 --> 00:23:30,580
So now what I want to do, is I want to
review the thing we did, and I want you

465
00:23:30,580 --> 00:23:32,895
to remember what the largest number is,
and I'm going to 

466
00:23:32,895 --> 00:23:35,760
show you a sequence of numbers in order.

467
00:23:35,760 --> 00:23:36,590
Ready?

468
00:23:36,590 --> 00:23:38,942
One, I'll do it kind of quickly, because
you've seen this before.

469
00:23:38,942 --> 00:23:41,630
So, I'm only showing you one number
at a time.

470
00:23:41,630 --> 00:23:44,110
So you want to tell me what the
largest number is.

471
00:23:44,110 --> 00:23:48,236
So here we go.
The first number is 9.

472
00:23:48,236 --> 00:23:52,125
The second number is 41.

473
00:23:52,125 --> 00:23:57,072
The third number is 12.
The fourth number is 3.

474
00:23:57,072 --> 00:24:03,697
The fifth number is 74.
And the sixth number is 15.

475
00:24:03,697 --> 00:24:05,790
So what was the largest number?

476
00:24:09,040 --> 00:24:12,735
Did you have to go back?
Or did you remember how to do it?

477
00:24:12,735 --> 00:24:17,978
Okay, well, I will give you a clue.
It was 74.

478
00:24:17,978 --> 00:24:20,440
Okay? That's because I know.

479
00:24:20,440 --> 00:24:24,450
Okay, now if you did that and you had to
do that for 20 or 30 numbers,

480
00:24:24,450 --> 00:24:26,680
you'd have to create a mental algorithm in

481
00:24:26,680 --> 00:24:31,148
your head to approach it and stay
concentrated, focused.

482
00:24:31,148 --> 00:24:33,530
So, you would've created a
variable in your head

483
00:24:33,530 --> 00:24:35,170
called largest_so_far.

484
00:24:36,610 --> 00:24:40,020
I would show you the first number, which
would be 9, and you would go hmm.

485
00:24:40,020 --> 00:24:43,120
Well, 9 is larger than 1, negative 1.

486
00:24:43,120 --> 00:24:46,430
So I will keep that. That's the new
largest I've seen so far.

487
00:24:46,430 --> 00:24:50,062
That's pretty awesome, because it's way
better than negative 1.

488
00:24:50,062 --> 00:24:54,860
41? I thought 9 was good.
But 41, that is a lot better.

489
00:24:54,860 --> 00:24:55,822
So I'm going to keep that one.

490
00:24:55,822 --> 00:24:58,831
That's the, that's the best.
It's the largest we've seen so far.

491
00:24:58,831 --> 00:24:59,779
We've only seen two numbers.

492
00:25:00,890 --> 00:25:03,460
But the best we've so far is 41.

493
00:25:03,460 --> 00:25:08,520
So 12 is not larger. Who, who
cares about that?

494
00:25:08,520 --> 00:25:12,060
It's not as big as 41 so we'll just go
right on to the next, on to the next.

495
00:25:12,060 --> 00:25:16,220
3, that's lame when we are
looking for large numbers.

496
00:25:16,220 --> 00:25:19,640
So we skip, oh, 74. 74, that's a
rockingly large number.

497
00:25:19,640 --> 00:25:20,870
So we're going to, that's a lot.

498
00:25:20,870 --> 00:25:23,180
That's actually the largest we've
seen so far

499
00:25:23,180 --> 00:25:26,214
because it's bigger than 41,
and 41 was the former champion 

500
00:25:26,214 --> 00:25:31,410
largest we've seen so far.
And there's 74, so we keep that one.

501
00:25:31,410 --> 00:25:33,900
I don't know how many letters, of these
things you're going to see, right?

502
00:25:33,900 --> 00:25:37,930
We could see lots of them.
But the next one we see 15.

503
00:25:37,930 --> 00:25:39,550
Well, that's no good.

504
00:25:39,550 --> 00:25:43,010
We've got 74 already.
74's like totally awesome.

505
00:25:43,010 --> 00:25:43,620
Right?

506
00:25:43,620 --> 00:25:45,260
So now, oh, we're done.

507
00:25:45,260 --> 00:25:49,550
So, hey, we're done and so 74
is the champion.

508
00:25:50,660 --> 00:25:51,670
That is the largest.

509
00:25:51,670 --> 00:25:57,160
It's not even the largest so far
any more, it's actually the largest.

510
00:25:57,160 --> 00:25:58,560
It's the largest.

511
00:25:58,560 --> 00:26:01,710
So again, we had this thing
at the top, we had this loop in

512
00:26:01,710 --> 00:26:04,190
the middle, and at the bottom is 
where you kind of get the payoff.

513
00:26:04,190 --> 00:26:05,480
And the payoff is

514
00:26:05,480 --> 00:26:07,090
not in the middle.

515
00:26:07,090 --> 00:26:09,220
while we're largest so far, largest so
far, largest so far,

516
00:26:09,220 --> 00:26:10,690
but at the end it turned out

517
00:26:10,690 --> 00:26:12,270
once you've looked at all the variables,

518
00:26:12,270 --> 00:26:16,330
all the values, the largest so far
is indeed the largest.

519
00:26:16,330 --> 00:26:16,940
Okay.

520
00:26:16,940 --> 00:26:19,180
So here's the algorithm for this.

521
00:26:19,180 --> 00:26:20,960
I have some variables, and remember

522
00:26:20,960 --> 00:26:24,820
that underscores are valid characters in
variables.

523
00:26:24,820 --> 00:26:28,650
Now [COUGH] I'm being a little
over-explicit in this.

524
00:26:28,650 --> 00:26:31,540
So I have a variable called
largest_so_far.

525
00:26:31,540 --> 00:26:37,003
Then what I do is I set it to 1,
negative 1.

526
00:26:37,003 --> 00:26:41,879
Then I print Before so we can see that
largest_so_far is negative 1.

527
00:26:41,879 --> 00:26:46,133
Then we have a for loop and my variable
iteration variable is the_num.

528
00:26:46,133 --> 00:26:50,953
So that's going to take on the successive
values: 9, 41, 12, 3, 74, 15,

529
00:26:50,953 --> 00:26:54,233
and run this indented loop of code, okay?

530
00:26:54,233 --> 00:26:59,122
And so the_num will be 9,
first time through.

531
00:26:59,122 --> 00:27:02,172
If the_num, 9, is greater than

532
00:27:02,172 --> 00:27:07,418
largest_so_far, then grab the_num
and assign

533
00:27:07,418 --> 00:27:13,364
it into largest_so_far.
Then print at the end of each loop,

534
00:27:13,364 --> 00:27:18,990
largest_so_far and the_num.
So, so, in effect, the_num is 9.

535
00:27:18,990 --> 00:27:22,840
We compare it to negative 1, and
negative 1, 9 is higher.

536
00:27:22,840 --> 00:27:25,265
So we make largest_so_far be 9.

537
00:27:27,370 --> 00:27:32,710
Next time through the loop, next time
through the loop, num is 41.

538
00:27:32,710 --> 00:27:38,180
So we compare largest_so_far with 41, and
we like it, so we store it.

539
00:27:38,180 --> 00:27:42,080
So we like it, we run it, and we print
our 41 is the largest we've seen so far.

540
00:27:43,330 --> 00:27:44,700
And we run again.

541
00:27:44,700 --> 00:27:49,816
We come in, the_num now points to 12.
the_num, 12, is

542
00:27:49,816 --> 00:27:55,152
not greater than 41, and so we skip.
So, the largest

543
00:27:55,152 --> 00:28:03,299
so far stays 41, and we see 12.
Similarly, the_num advances to 3.

544
00:28:03,299 --> 00:28:04,578
We skip.

545
00:28:04,578 --> 00:28:08,059
So we saw 3, but the largest
so far is still 41.

546
00:28:08,059 --> 00:28:13,900
Continuing, the_num is now 74.
It runs, 74 is

547
00:28:13,900 --> 00:28:20,306
greater than 41, and so we run
this code. And so we say 74

548
00:28:20,306 --> 00:28:24,520
is stuck in largest_so_far,
and indeed, then we print

549
00:28:24,520 --> 00:28:27,381
it out, and largest so far is now 74.

550
00:28:27,381 --> 00:28:29,139
We continue on.

551
00:28:29,139 --> 00:28:30,508
We go up one more time.

552
00:28:30,508 --> 00:28:35,535
The_num points to 15, but 15
is not larger than 74.

553
00:28:35,535 --> 00:28:36,760
And so we skip.

554
00:28:36,760 --> 00:28:40,840
We print out 15 and 74, and then
we come out and

555
00:28:40,840 --> 00:28:44,700
at the end, at the end, we get
the largest so far.

556
00:28:44,700 --> 00:28:46,400
It, the name no matter, no longer,

557
00:28:46,400 --> 00:28:48,330
I mean it's kind of the largest

558
00:28:48,330 --> 00:28:51,540
so far at the end is the largest,
but the variable name.

559
00:28:51,540 --> 00:28:53,320
Okay? Got it?

560
00:28:55,590 --> 00:28:59,230
That's one idiom.
So let's just switch to another idiom.

561
00:29:00,570 --> 00:29:02,510
Now counting, how many things are we

562
00:29:02,510 --> 00:29:04,170
going to, how many times is loop
going to execute?

563
00:29:04,170 --> 00:29:06,380
How things are we going to find
in the loop?

564
00:29:06,380 --> 00:29:08,020
It's all kind of the same notion.

565
00:29:08,020 --> 00:29:11,706
And the pattern is really simple.
We start some variable zork.

566
00:29:11,706 --> 00:29:13,133
A better name for this would be count.

567
00:29:13,133 --> 00:29:15,870
But I want to call it zork.

568
00:29:15,870 --> 00:29:20,435
And then we have a loop, and then in the
loop we just add 1 to zork,

569
00:29:20,435 --> 00:29:22,076
and at the end, zork.

570
00:29:22,076 --> 00:29:26,880
That should be light blue right there.
zork should be the total count.

571
00:29:26,880 --> 00:29:29,530
Now of course we can look at it and say
it's going to be 6, but

572
00:29:29,530 --> 00:29:31,780
assume this loop is looping through a
million

573
00:29:31,780 --> 00:29:33,338
lines in the file or something like that.

574
00:29:33,338 --> 00:29:38,598
So it's [SOUND], so it's cheating to
kind of look at it and say, ooh, it's 6,

575
00:29:38,598 --> 00:29:41,520
because we want to actually compute it.
So it's really simple.

576
00:29:41,520 --> 00:29:45,892
You know, zork starts at 0.
It's going to run zork is 1 now, and

577
00:29:45,892 --> 00:29:52,290
2, 3, 4, 5, 6, and then we've run out of
stuff and then we print out 6.

578
00:29:52,290 --> 00:29:53,000
Okay?

579
00:29:53,000 --> 00:29:54,261
So that's kind of the idiom, right?

580
00:29:54,261 --> 00:29:59,160
Before, during, and after, right?
We do something before, we do

581
00:29:59,160 --> 00:30:05,090
something during, and, and in a sense this
zork here is the number we've seen so far.

582
00:30:05,090 --> 00:30:07,260
And at the end it becomes kind of the
total number.

583
00:30:10,090 --> 00:30:12,360
Summing in a loop, very similar.

584
00:30:12,360 --> 00:30:16,410
Again, you have to think of this is, there
is a whole bunch of variables here.

585
00:30:16,410 --> 00:30:18,860
We start a variable at 0.

586
00:30:18,860 --> 00:30:22,333
Each time through the loop, we add
whatever it is that we're seeing.

587
00:30:22,333 --> 00:30:27,622
Instead of adding 1 we're
adding 9, 41, 12, 3, 74, 15.

588
00:30:27,622 --> 00:30:34,292
And zork would be best thought of as
running total.

589
00:30:34,292 --> 00:30:35,910
So, zork is the running total.

590
00:30:35,910 --> 00:30:38,610
And so if we look at the numbers 9,

591
00:30:38,610 --> 00:30:43,500
running total's 9, running total's 50, 
running total's 62, 65, 139, 154.

592
00:30:43,500 --> 00:30:47,790
And then we skip out and at the end, the
running total becomes the total.

593
00:30:49,150 --> 00:30:50,330
Okay?

594
00:30:50,330 --> 00:30:53,350
So, that's another of these patterns
that, sort of,

595
00:30:53,350 --> 00:30:54,730
we do something at the beginning, we

596
00:30:54,730 --> 00:30:57,880
do something in the middle, and we have

597
00:30:57,880 --> 00:31:00,920
something very nice for ourselves
at the end.

598
00:31:04,800 --> 00:31:07,320
Finding the average of a sequence of
values

599
00:31:07,320 --> 00:31:10,740
is the combination of the
two previous patterns.

600
00:31:10,740 --> 00:31:14,190
This time I am going to use
more mnemonic variables.

601
00:31:14,190 --> 00:31:15,850
A variable called count.

602
00:31:15,850 --> 00:31:17,560
Everyone calls this count.

603
00:31:17,560 --> 00:31:20,977
Sum, now total would maybe be
a better word for this.

604
00:31:20,977 --> 00:31:25,177
The running total. And then, so the count
and the sum start out at 0, and

605
00:31:25,177 --> 00:31:30,327
then each time through the loop, count equals
count plus 1, so we're adding 1 to count.

606
00:31:30,327 --> 00:31:33,616
Sum equal sum plus value, so we're
adding 1 to to sum.

607
00:31:33,616 --> 00:31:35,120
I mean adding the value.

608
00:31:35,120 --> 00:31:39,310
Value of course being
9, 41, 12, 3, 74, 15.

609
00:31:39,310 --> 00:31:42,390
And then at the very end we can
print out the number.

610
00:31:42,390 --> 00:31:47,190
We have six things with a total of 154,
and then we calculate the average.

611
00:31:47,190 --> 00:31:51,800
Of course these are integer numbers, and
so this is a truncating division.

612
00:31:51,800 --> 00:31:55,715
So 154 over 6 equals 25 and

613
00:31:55,715 --> 00:31:58,831
not 25 point something.

614
00:31:58,831 --> 00:32:01,910
In Python 3000, Python 3, it'd be better.

615
00:32:01,910 --> 00:32:08,004
But so the average, the integer average is
of the numbers we just looked at, is 25.

616
00:32:08,004 --> 00:32:11,610
So sometimes we're searching, like
for a needle in a haystack.

617
00:32:11,610 --> 00:32:15,460
Looking for something and again
you have to think of like

618
00:32:15,460 --> 00:32:18,610
you're handed some amount of data and you
gotta hunt for something.

619
00:32:18,610 --> 00:32:20,980
And there might be a million things and
you might only want five of them.

620
00:32:20,980 --> 00:32:22,450
And you can either look by hand
or you can write

621
00:32:22,450 --> 00:32:25,430
a loop that's got an if statement that
says found it.

622
00:32:25,430 --> 00:32:28,300
Maybe I found it at line seven
or found it wherever.

623
00:32:28,300 --> 00:32:31,620
So this is filtering or finding or
searching, looking

624
00:32:31,620 --> 00:32:33,830
for a needle in a haystack, in a loop.

625
00:32:34,850 --> 00:32:38,210
And so the, the idea basically is
that we have this loop,

626
00:32:38,210 --> 00:32:42,865
it's going to go through all the
values, 9, 41, 12, 3, 74.

627
00:32:42,865 --> 00:32:46,290
But we put in the loop, we embed
an if statement.

628
00:32:46,290 --> 00:32:49,300
If the value we're looking at is greater
than 20, print I found it.

629
00:32:50,390 --> 00:32:57,764
So when value is 9, this is going to do
nothing and just go and make value be 41.

630
00:32:57,764 --> 00:33:02,500
And then value 41, oop, yep, there we go,
print Large number, so off this comes.

631
00:33:03,840 --> 00:33:07,746
Then value becomes 12, nothing happens,
value becomes 3, nothing happens, 

632
00:33:07,746 --> 00:33:11,580
value becomes 74, oops, this
time it's going to happen.

633
00:33:11,580 --> 00:33:13,920
So out comes Large number 74.

634
00:33:13,920 --> 00:33:18,550
Then value becomes 15, nothing happens,
and then value is all done,

635
00:33:18,550 --> 00:33:20,610
and so it comes and finishes.

636
00:33:20,610 --> 00:33:26,257
So this is the searching or
filtering or catching or, or whatever.

637
00:33:26,257 --> 00:33:28,473
Okay?

638
00:33:29,473 --> 00:33:31,503
We can also sort of, if we don't just want

639
00:33:31,503 --> 00:33:34,446
to print everything out, we want to
say is something in there.

640
00:33:34,446 --> 00:33:36,152
Go look through this million things and

641
00:33:36,152 --> 00:33:38,831
tell me if blah exists.

642
00:33:38,831 --> 00:33:42,150
And in this we're going to introduce the
notion of Boolean variable.

643
00:33:42,150 --> 00:33:43,820
A Boolean is a true-false.

644
00:33:43,820 --> 00:33:47,200
It only has two values and we've
already used it in the while True.

645
00:33:47,200 --> 00:33:56,537
So that capital True, that is a constant,
just like 7 or 42 or 99, or "Sam".

646
00:33:56,537 --> 00:33:58,410
And so we're going to make this
variable called found.

647
00:33:58,410 --> 00:34:02,510
Now found is a mnemonic value, variable.
It's just a name I picked.

648
00:34:02,510 --> 00:34:04,220
So found equals False.

649
00:34:04,220 --> 00:34:06,380
This is going to be false,
until we find what

650
00:34:06,380 --> 00:34:08,880
we're looking for and then it's
going to switch to true.

651
00:34:08,880 --> 00:34:11,100
So it starts out and it's false.

652
00:34:11,100 --> 00:34:13,870
Then we're going to run this
bit of code three times.

653
00:34:15,760 --> 00:34:18,540
And if the value that we are looking at
is 3, then we're going

654
00:34:18,540 --> 00:34:23,430
to set found to be true, and we'll print
found value each time through.

655
00:34:23,430 --> 00:34:27,796
So value's going to take on 9, 41, 12, 3,
74, so we get a line

656
00:34:27,796 --> 00:34:30,904
of output for each one. And the
first time through

657
00:34:30,904 --> 00:34:33,804
it's not yet found, because we're
looking at a 9.

658
00:34:33,804 --> 00:34:35,271
Second time, it's not yet found.

659
00:34:35,271 --> 00:34:38,830
We looked at 41, still false. So it could
stay false for long time.

660
00:34:39,940 --> 00:34:41,180
Oh, we found a true.

661
00:34:41,180 --> 00:34:43,360
And then that means that this code is
going to run once.

662
00:34:43,360 --> 00:34:46,306
And so you can kind of think of this
found variable as sticky.

663
00:34:46,306 --> 00:34:49,342
It's going to stay false, and then
the rest of the loop

664
00:34:49,342 --> 00:34:52,590
it's going to stay true, and at
the end it is true.

665
00:34:52,590 --> 00:34:53,860
Now the way we usually do these
kinds of things

666
00:34:53,860 --> 00:34:54,750
is we don't bother with this
print statement,

667
00:34:54,750 --> 00:34:57,970
so we wouldn't see all this stuff.

668
00:34:57,970 --> 00:35:00,349
All we'd see is Before False, After True.

669
00:35:00,349 --> 00:35:02,800
And After would just tell us 
that yeah, we found it.

670
00:35:02,800 --> 00:35:06,130
There was a 3 somewhere in
that long list of numbers.

671
00:35:06,130 --> 00:35:08,150
Okay? I am just adding this print
statement so we can 

672
00:35:08,150 --> 00:35:13,530
kind of trace it. But basically this
loop, sort  of from here to here, is asking

673
00:35:13,530 --> 00:35:18,130
the question, is there the number 3 in the
list that we're about to go through?

674
00:35:19,260 --> 00:35:20,360
Okay?
Now...

675
00:35:21,870 --> 00:35:25,860
How could, I'll just give you a second and
ask you a quick question.

676
00:35:25,860 --> 00:35:27,000
You can pause if you want.

677
00:35:29,130 --> 00:35:32,360
How could you improve this loop
using the break?

678
00:35:32,360 --> 00:35:34,845
Where might you put a break
to make this loop smarter?

679
00:35:34,845 --> 00:35:41,230
[SOUND].

680
00:35:41,230 --> 00:35:44,380
It's okay if you didn't, if it
doesn't jump out at you.

681
00:35:44,380 --> 00:35:46,880
So, if you think about it.

682
00:35:46,880 --> 00:35:51,307
Once you hit true, there's really little
point in looking at the rest of them.

683
00:35:51,307 --> 00:35:55,307
There just is no point.
So we could put a break right here.

684
00:35:56,580 --> 00:36:01,190
Inside this block.
You'd say, look, I'm looking for a 3.

685
00:36:01,190 --> 00:36:03,240
All I care is whether I found it or not.

686
00:36:03,240 --> 00:36:08,440
If I find it, I mark it to true that I
found it, and I get out of the loop.

687
00:36:08,440 --> 00:36:09,530
Why bother?

688
00:36:09,530 --> 00:36:10,820
Why do all these things?

689
00:36:10,820 --> 00:36:13,100
Right, just get out.
Okay?

690
00:36:13,100 --> 00:36:14,990
So don't worry about it.

691
00:36:14,990 --> 00:36:18,490
I'm just pointing that out, that's one of
the places where break could be used.

692
00:36:18,490 --> 00:36:21,660
The loop functions either way it just, it
just loops through all the rest

693
00:36:21,660 --> 00:36:22,250
of them as well.

694
00:36:24,610 --> 00:36:26,540
Okay. So.

695
00:36:27,730 --> 00:36:33,590
Here's this largest value one I've used
before and you know, away we go.

696
00:36:33,590 --> 00:36:36,510
We, you know, we have
largest_so_far, we check to see 

697
00:36:36,510 --> 00:36:38,310
if the one we're looking at is better

698
00:36:38,310 --> 00:36:44,610
and if it is we keep it and then away we
go and we find that the largest is 17.

699
00:36:44,610 --> 00:36:45,730
What if...

700
00:36:46,840 --> 00:36:49,960
What would you have to change in this

701
00:36:49,960 --> 00:36:53,740
code to make this search for the
smallest of all the values?

702
00:36:56,210 --> 00:36:58,190
Like point, point where in the screen.

703
00:36:59,670 --> 00:37:02,870
Where, what would you have to change to

704
00:37:02,870 --> 00:37:05,440
make this look for the smallest
in the list of values?

705
00:37:07,210 --> 00:37:11,900
What is the nature of what's making this
about being largest?

706
00:37:11,900 --> 00:37:14,250
What would you change?
Okay.

707
00:37:16,260 --> 00:37:16,980
Pause if you like.

708
00:37:19,490 --> 00:37:24,140
So here is some things that you might do
to make it work about the smallest.

709
00:37:24,140 --> 00:37:25,670
So, hey, one thing we would do.

710
00:37:25,670 --> 00:37:29,688
Let's change the name of the variable.
We had a variable named largest_so_far.

711
00:37:29,688 --> 00:37:32,240
And now we'll change it to be called
smallest_so_far.

712
00:37:33,840 --> 00:37:36,498
Changing the variable name doesn't
change the program at all.

713
00:37:36,498 --> 00:37:38,480
But it makes the program easier to read.

714
00:37:38,480 --> 00:37:40,230
If the program works.

715
00:37:40,230 --> 00:37:41,940
So, it's like smallest so far.

716
00:37:41,940 --> 00:37:44,460
Okay, but that didn't make it
about being small.

717
00:37:44,460 --> 00:37:47,320
The thing that made it about being small

718
00:37:47,320 --> 00:37:50,030
is change this greater than to a less than.

719
00:37:51,250 --> 00:37:54,580
Because we're kind of thinking when
we're doing largest so far, if the

720
00:37:54,580 --> 00:37:59,020
number we're looking at is bigger than
the largest so far, we keep it.

721
00:37:59,020 --> 00:38:01,210
If the number we're looking at in
the smallest is

722
00:38:01,210 --> 00:38:03,440
smaller than the smallest so far,
then we want to keep it.

723
00:38:03,440 --> 00:38:04,080
So this is like,

724
00:38:06,310 --> 00:38:09,790
this line here is the keeping line
and this is the when line.

725
00:38:09,790 --> 00:38:13,749
When to keep.

726
00:38:13,749 --> 00:38:15,370
We'll keep it if it's smaller.

727
00:38:16,420 --> 00:38:17,720
Okay?

728
00:38:17,720 --> 00:38:20,900
So that's the key, and so yeah,
so I name it smallest_so_far,

729
00:38:20,900 --> 00:38:24,680
whoop de do. That's good.
But the real thing that

730
00:38:24,680 --> 00:38:27,930
had this being about largeness and
smallness was whether this, this less

731
00:38:27,930 --> 00:38:31,490
than and greater than and this was the
repeated code that got re-checked

732
00:38:31,490 --> 00:38:35,590
over and over again.
So, but this still has a bug in it.

733
00:38:36,750 --> 00:38:39,320
So let's run this visually.

734
00:38:41,590 --> 00:38:42,330
Okay.

735
00:38:42,330 --> 00:38:44,610
So now we've got a variable called
smallest so far.

736
00:38:45,898 --> 00:38:48,230
We are going to check to see if
a series of numbers that

737
00:38:48,230 --> 00:38:51,000
I'm about to show you are smaller
than the smallest so far.

738
00:38:53,130 --> 00:38:57,375
So the first number is 9.
Is that smaller than negative 1?

739
00:38:59,240 --> 00:39:01,760
No, it's not.
Negative 1 is smaller.

740
00:39:01,760 --> 00:39:06,096
The second number is 41.
Is that smaller than negative 1?

741
00:39:06,096 --> 00:39:07,688
No, it is not.

742
00:39:07,688 --> 00:39:10,409
The next number is 12.
Is that smaller than negative 1?

743
00:39:10,409 --> 00:39:11,310
No.

744
00:39:11,310 --> 00:39:14,180
Negative 1 is smaller than 12.

745
00:39:14,180 --> 00:39:17,294
3? No, not smaller.

746
00:39:17,294 --> 00:39:20,673
74? No, not smaller.

747
00:39:20,673 --> 00:39:23,160
15? Not smaller.

748
00:39:23,160 --> 00:39:25,890
So, we're all done.

749
00:39:25,890 --> 00:39:29,590
Yay, and the smallest number we saw
in the list is...

750
00:39:32,000 --> 00:39:35,700
Negative 1?
Negative 1 wasn't even in the list.

751
00:39:35,700 --> 00:39:38,190
So that's not a very good program.

752
00:39:41,740 --> 00:39:44,880
So let's take a look at what went wrong
with this program.

753
00:39:44,880 --> 00:39:46,990
So we fixed it, we fixed it as
best we could. Right?

754
00:39:48,050 --> 00:39:52,590
We made it, we changed the words
largest to smallest and yay, that'll fix.

755
00:39:52,590 --> 00:39:54,920
Just makes it more readable, doesn't
actually change the program.

756
00:39:54,920 --> 00:39:58,530
And we made this less than, so now what
happens is it comes in,

757
00:39:58,530 --> 00:40:03,250
if 3 is less than negative 1, smallest so
far of course is negative 1.

758
00:40:03,250 --> 00:40:05,510
It, this just never runs.

759
00:40:05,510 --> 00:40:07,014
This never runs. And so

760
00:40:07,014 --> 00:40:12,090
as we print, smallest_so_far stays
negative 1 and oops, that

761
00:40:12,090 --> 00:40:18,420
should be negative 1, right there.
[LAUGH] I'm sorry, I forgot to fix that.

762
00:40:18,420 --> 00:40:20,520
Here, let me magically fix that.

763
00:40:21,950 --> 00:40:23,520
Boom. [SNAP]

764
00:40:23,520 --> 00:40:27,340
So let's take a look at what
went wrong with this.

765
00:40:27,340 --> 00:40:29,935
So here we have the code.
smallest_so_far is negative 1.

766
00:40:29,935 --> 00:40:32,383
We have it fixed so we're checking,
looking for smaller

767
00:40:32,383 --> 00:40:36,060
numbers rather than larger numbers, by
turning this to less than.

768
00:40:36,060 --> 00:40:43,110
But the first time through, 
smallest_so_far is negative 1 and the_num is 3.

769
00:40:43,110 --> 00:40:48,173
3 is not less than negative 1, so we skip
through and the printout of the

770
00:40:48,173 --> 00:40:50,299
first line is negative 1 3.

771
00:40:50,299 --> 00:40:54,320
And it doesn't take long to realize that
it's just going to keep doing this.

772
00:40:54,320 --> 00:40:57,380
smallest_so_far is going to stay
negative 1,

773
00:40:57,380 --> 00:40:59,620
no matter what we look at on this side.

774
00:40:59,620 --> 00:41:01,090
And then we're going to come out
at the end.

775
00:41:02,240 --> 00:41:07,225
And we end up with negative 1 as the
answer. Not very good.

776
00:41:07,225 --> 00:41:09,910
[SIGH].

777
00:41:09,910 --> 00:41:10,810
So the question is...

778
00:41:14,090 --> 00:41:18,220
What should we make this value be?
Negative 1?

779
00:41:18,220 --> 00:41:21,210
It barely worked in the largest because we
were working with positive

780
00:41:21,210 --> 00:41:24,320
numbers and so starting with negative 1
as the largest so far

781
00:41:24,320 --> 00:41:27,286
was a reasonable assumption as
long as the numbers were all positive.

782
00:41:27,286 --> 00:41:29,558
[SOUND].

783
00:41:29,558 --> 00:41:32,839
But what would be the number
to choose here?

784
00:41:32,839 --> 00:41:34,000
Think about that for a second.

785
00:41:34,000 --> 00:41:35,350
Pause if you have to.

786
00:41:35,350 --> 00:41:38,568
Let me clear it.
Let me make it real clear.

787
00:41:38,568 --> 00:41:41,695
[SOUND].
What's the right thing

788
00:41:41,695 --> 00:41:46,391
to put here? Okay.

789
00:41:46,391 --> 00:41:52,811
So, what? A million?

790
00:41:52,811 --> 00:41:58,524
That might work, a million might work.
But what if this number, you know,

791
00:41:58,524 --> 00:42:04,210
was, you know, what if, what if all
these numbers were larger

792
00:42:04,210 --> 00:42:07,020
than a million, okay?
Then, then that wouldn't work.

793
00:42:07,020 --> 00:42:12,200
So the problem is there's no real good
value, unless you could make this be

794
00:42:12,200 --> 00:42:17,100
somehow infinity, okay?
You could make this be infinity.

795
00:42:18,310 --> 00:42:24,010
But there is a way to do this in Python.
And it's a really kind of cool technique.

796
00:42:24,010 --> 00:42:26,730
It's sort of a way we signal ourselves,

797
00:42:26,730 --> 00:42:29,550
and that is we're going to use
a special value.

798
00:42:29,550 --> 00:42:30,318
Not negative 1.

799
00:42:30,318 --> 00:42:34,340
It's not a number. And the special value
we're going to use is None.

800
00:42:35,890 --> 00:42:41,160
It's a different type. It's not a number,
it's itself its own type.

801
00:42:41,160 --> 00:42:43,750
So what we're going to do is mark
smallest as "None".

802
00:42:43,750 --> 00:42:45,900
And, and, and sort of at a high level what

803
00:42:45,900 --> 00:42:49,990
we're really saying is we haven't seen
anything so far.

804
00:42:49,990 --> 00:42:52,940
The smallest we've seen so far is none.

805
00:42:52,940 --> 00:42:55,140
We've not seen anything so far.

806
00:42:55,140 --> 00:42:58,020
Now we have to change our loop,
our little if inside the loop.

807
00:42:58,020 --> 00:43:00,480
This is this intelligence in the middle.

808
00:43:00,480 --> 00:43:02,580
First we say if smallest is None.

809
00:43:02,580 --> 00:43:06,300
is is an operator, part of the
Python language.

810
00:43:06,300 --> 00:43:10,190
If smallest is None, exactly the
same as None,

811
00:43:10,190 --> 00:43:12,430
then the smallest we've seen so far
is the value.

812
00:43:12,430 --> 00:43:17,132
Now this is going to happen the first time
[SOUND].

813
00:43:17,132 --> 00:43:20,268
Because smallest starts out None and then
as soon as we set smallest

814
00:43:20,268 --> 00:43:23,808
to the value, it's going to be that first
number, so it's going to be 9.

815
00:43:23,808 --> 00:43:26,947
Okay? So the smallest is quickly
going to become 9.

816
00:43:26,947 --> 00:43:33,010
Then we print out the new, the smallest
is 9 after we've seen the 9.

817
00:43:33,010 --> 00:43:37,010
Then we go up to the top and we say, is
smallest None?

818
00:43:37,010 --> 00:43:41,219
And the answer is no it is not,
because smallest is now 9.

819
00:43:41,219 --> 00:43:46,080
Then this else-if is going to ask, is the
value we're looking at, which is 41,

820
00:43:46,080 --> 00:43:50,650
is the value less than smallest?
Well, no, it is not.

821
00:43:50,650 --> 00:43:52,360
9 is smaller than 41.

822
00:43:52,360 --> 00:43:56,090
And, so in a sense, after the
first time it's executed,

823
00:43:56,090 --> 00:43:58,050
after the first time the statement
is executed,

824
00:43:58,050 --> 00:43:59,800
this is going to always be false, right?

825
00:43:59,800 --> 00:44:02,200
Because smallest is no longer None
and this is going to be 

826
00:44:02,200 --> 00:44:04,850
the thing that really is operating.

827
00:44:04,850 --> 00:44:06,270
And then it's going to work.

828
00:44:06,270 --> 00:44:09,380
And when we, you know, smallest will
become 9.

829
00:44:09,380 --> 00:44:11,270
The smallest so far is 9, but then we see

830
00:44:11,270 --> 00:44:14,955
the 3 finally, and the value of
the 3 is less than 9.

831
00:44:14,955 --> 00:44:17,520
And so then we take 3 and we stick it into

832
00:44:17,520 --> 00:44:21,560
smallest and we end up with this,
and then the loop

833
00:44:21,560 --> 00:44:24,315
runs some more times, and when
we're all done we have 3.

834
00:44:25,510 --> 00:44:29,860
So the trick here is we put this
None in, and we have a

835
00:44:29,860 --> 00:44:33,510
little more if code to check to see
if we haven't seen anything so far.

836
00:44:33,510 --> 00:44:35,584
This is what, you can think of this

837
00:44:35,584 --> 00:44:41,205
as a way to trigger on the first,
first iteration.

838
00:44:41,205 --> 00:44:43,557
Special code that's really going to, it
could, it looks at it

839
00:44:43,557 --> 00:44:46,499
on each iteration, but it's never true
after the first iteration.

840
00:44:47,530 --> 00:44:49,410
Okay? So that's just a technique.

841
00:44:52,150 --> 00:44:54,840
So this is and the is not operator,
I think it's a real elegant thing.

842
00:44:54,840 --> 00:45:01,760
Don't start overusing it. It's,
at a low level

843
00:45:01,760 --> 00:45:05,780
its real meaning is exactly the
same as in type and value.

844
00:45:07,570 --> 00:45:11,040
There's an is and there's an
is not, but don't, like,

845
00:45:11,040 --> 00:45:15,530
say, like, if, don't do things like
saying if i equals.

846
00:45:15,530 --> 00:45:20,070
Oops.
I won't even let myself type the bad code.

847
00:45:20,070 --> 00:45:22,850
if i is 4.

848
00:45:22,850 --> 00:45:26,030
Don't say that, okay? Don't say that.

849
00:45:26,030 --> 00:45:27,680
Don't do if i is 4.

850
00:45:30,490 --> 00:45:34,078
It may work in certain situations.
It's really best used in very limited

851
00:45:34,078 --> 00:45:36,564
situations where you're checking
for some of these

852
00:45:36,564 --> 00:45:40,735
special values like None and False.

853
00:45:40,735 --> 00:45:41,570
Okay.

854
00:45:41,570 --> 00:45:45,810
The problem is if you use equality here,
it tries to kind of

855
00:45:45,810 --> 00:45:50,586
convert values and it may end up
giving you a false yes.

856
00:45:50,586 --> 00:45:54,450
And so is is a stronger equality than
simple equals.

857
00:45:56,190 --> 00:46:02,710
Equals is same value, same numeric value,
whereas is is exactly the same thing.

858
00:46:02,710 --> 00:46:05,978
But don't, don't overuse is. Use
double equals

859
00:46:05,978 --> 00:46:09,140
95% of the time and use is when you're

860
00:46:09,140 --> 00:46:12,530
checking if it's one of these special
constants like True or False.

861
00:46:13,890 --> 00:46:14,390
Okay?

862
00:46:16,020 --> 00:46:19,340
Okay.
So this is a iterations.

863
00:46:19,340 --> 00:46:21,190
I mean our loops are going to get more
sophisticated and

864
00:46:21,190 --> 00:46:23,570
we have more interesting things
to do, but we,

865
00:46:23,570 --> 00:46:24,940
you know, we talked about some

866
00:46:24,940 --> 00:46:28,370
indefinite loops, definite loops,
iteration variables.

867
00:46:28,370 --> 00:46:33,130
Some patterns like maximum, minimum,
summing, averaging, you know.

868
00:46:33,130 --> 00:46:37,490
We introduced the concept of None, you
know, and, and so this is.

869
00:46:37,490 --> 00:46:40,320
We're getting there, we've got a couple
more chapters before we really

870
00:46:40,320 --> 00:46:43,470
start hitting the data analysis, so see
you in the next lecture.

